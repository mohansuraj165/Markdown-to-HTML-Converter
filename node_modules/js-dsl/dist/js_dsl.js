'use strict';

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/* eslint-disable class-methods-use-this,template-curly-spacing */
// Copyright 2017, Venkat Peri.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var _ = require('lodash');

var _require = require('events'),
    EventEmitter = _require.EventEmitter;

var debug = require('debug')('js_dsl');

var _require2 = require('./util'),
    extractArgOfType = _require2.extractArgOfType;

/**
 * A groovy-builder like object-tree builder for developing
 * JavaScript DSLs.
 */


var JsDsl = function (_EventEmitter) {
  _inherits(JsDsl, _EventEmitter);

  function JsDsl(name, parentBuilder, rootObj) {
    _classCallCheck(this, JsDsl);

    var _this = _possibleConstructorReturn(this, (JsDsl.__proto__ || Object.getPrototypeOf(JsDsl)).call(this));

    if (typeof name !== 'string' || arguments.length < 3) {
      var _ref = [null, name, parentBuilder];
      // eslint-disable-next-line no-param-reassign

      name = _ref[0];
      parentBuilder = _ref[1];
      rootObj = _ref[2];
    }

    _this._name = name;
    _this._parentBuilder = parentBuilder;
    _this.__contextStack = [];
    _this._globalsStack = {};
    _this._factories = {};
    _this._propertyNames = [];
    _this._methodNames = [];
    _this.__rootObj = rootObj || global || window;
    _this.register();
    _this._emit('register', _this);
    return _this;
  }

  _createClass(JsDsl, [{
    key: '_createNode',


    /**
     * Creates a node with the supplied arguments.
     * @param name {String} the name of the node
     * @param args {*[]} optional arguments passed to the node's constructor
     * @returns {Object} the newly constructed node.
     * @private
     */
    value: function _createNode(name) {
      debug('createNode: ' + name);

      var factory = this._resolveFactory(name);
      if (!factory) {
        throw new Error('Don\'t know how to create ' + name);
      }

      this._child.builder = this;
      var childBuilder = factory.getBuilder(this);

      if (childBuilder) {
        this._child.builder = childBuilder;
        this._child.usesCustomBuilder = true;
      }

      this._current.factory = factory;
      this._current.name = name;

      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      this._emit.apply(this, ['preInstantiate', this, name].concat(args));

      var node = factory.newInstance.apply(factory, [this, name].concat(args));
      if (!node) {
        debug('factory returned null for ' + name);
        return null;
      }

      this._emit('postInstantiate', this, name, node);
      return node;
    }

    /**
     * Creates a new node with the given {name} and applies
     * the given configuration closure on it.
     *
     * @param name {String} the name of the node
     * @param closure {Function} optional - configures the newly created node.
     * @param args {*[]} Arguments supplied to the node constructor.
     * @returns {Object} The newly created node
     * @private
     */

  }, {
    key: '_dispatchNodeCall',
    value: function _dispatchNodeCall(name, closure) {
      var needToPop = false;

      if (!this._context) {
        this._pushContext();
        needToPop = true;
      }

      for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
        args[_key2 - 2] = arguments[_key2];
      }

      var node = this._createNode.apply(this, [name].concat(args));

      var currentNode = this._current.node;
      if (currentNode) {
        this._setParent(currentNode, node);
      }

      if (closure) {
        var parentFactory = this._current.factory;
        var parentName = this._current.name;
        var parentContext = this._context;

        if (parentFactory.isLeaf()) {
          throw new TypeError('"' + name + '" does not support nesting.');
        }

        this._pushContext({
          _current: _.extend({ node: node }, parentContext._child),
          _parent: {
            factory: parentFactory,
            node: currentNode,
            _context: parentContext,
            name: parentName,
            builder: parentContext._current.builder
          }
        });

        try {
          if (this._current.usesCustomBuilder) {
            this._current.builder._registerGlobals();
          }
          this._emit('beforeConfigureNode', this, node);
          closure.call(this, node);
          this._emit('afterConfigureNode', this, node);
        } finally {
          if (this._current.usesCustomBuilder) {
            this._current.builder._unregisterGlobals();
          }
        }

        this._popContext();
      }

      this._nodeCompleted(currentNode, node);
      this._emit('nodeCompleted', this, currentNode, node);

      if (needToPop) {
        this._popContext();
      }
      return node;
    }

    /**
     * Emitter helper. Bubbles events up the builder tree.
     * @param name {String} the event name
     * @param args {...*} optional event arguments
     * @private
     */

  }, {
    key: '_emit',
    value: function _emit(name) {
      for (var _len3 = arguments.length, args = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
        args[_key3 - 1] = arguments[_key3];
      }

      this.emit.apply(this, [name].concat(args));
      if (this._parentBuilder) {
        var _parentBuilder;

        (_parentBuilder = this._parentBuilder)._emit.apply(_parentBuilder, [name].concat(args));
      }
    }
  }, {
    key: '_nodeCompleted',
    value: function _nodeCompleted(parent, child) {
      this._current.factory.onNodeCompleted(this._child.builder, parent, child);
    }
  }, {
    key: '_popContext',
    value: function _popContext() {
      this._contextStack.pop();
    }
  }, {
    key: '_pushContext',
    value: function _pushContext(ctx) {
      this._contextStack.push(_.extend({}, {
        _current: {},
        _child: {},
        _parent: {}
      }, ctx));
    }

    /**
     * Registers a factory with the given name. Pushes an
     * existing factory on the global stack if, if one
     * is already registered for the given name.
     *
     * @param name {String} the name of the node created by this factory
     * @private
     */

  }, {
    key: '_registerFactory',
    value: function _registerFactory(name) {
      var that = this;
      if (this._rootObj[name]) {
        this._globalsStack[name] = this._globalsStack[name] || [];
        this._globalsStack[name].push(this._rootObj[name]);
      }

      this._rootObj[name] = function () {
        for (var _len4 = arguments.length, arg = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
          arg[_key4] = arguments[_key4];
        }

        var _extractArgOfType = extractArgOfType(arg, 'function'),
            _extractArgOfType2 = _slicedToArray(_extractArgOfType, 2),
            closure = _extractArgOfType2[0],
            args = _extractArgOfType2[1];

        return that._dispatchNodeCall.apply(that, [name, closure].concat(_toConsumableArray(args)));
      };
    }

    /**
     * Register global objects (factories, properties and methods).
     * @private
     */

  }, {
    key: '_registerGlobals',
    value: function _registerGlobals() {
      if (this._globalsRegistered) {
        return;
      }

      Object.getOwnPropertyNames(this._factories).forEach(this._registerFactory.bind(this));

      this._propertyNames.forEach(this._registerProperty.bind(this));

      this._methodNames.forEach(this._registerMethod.bind(this));

      this._globalsRegistered = true;
    }

    /**
     * Registers a method with name for the current builder.
     *
     * @param name {String} the method name
     * @private
     */

  }, {
    key: '_registerMethod',
    value: function _registerMethod(name) {
      var that = this;
      if (this._rootObj[name]) {
        this._globalsStack[name] = this._globalsStack[name] || [];
        this._globalsStack[name].push(this._rootObj[name]);
      }
      // keep as a fn call, since _current may
      // not be defined yet.
      this._rootObj[name] = function () {
        var _that$_current$node$n;

        for (var _len5 = arguments.length, args = Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
          args[_key5] = arguments[_key5];
        }

        return (_that$_current$node$n = that._current.node[name]).call.apply(_that$_current$node$n, [that._current.node].concat(args));
      };
    }

    /**
     * Registers a property with the given name for the current
     * builder.
     *
     * @param name {String} the property name
     * @private
     */

  }, {
    key: '_registerProperty',
    value: function _registerProperty(name) {
      var that = this;
      if (this._rootObj[name]) {
        that.emit('error', new Error(name + ' already exists on global'));
      }

      Object.defineProperty(this._rootObj, name, {
        configurable: true,
        get: function get() {
          return that._current.node[name];
        },
        set: function set(v) {
          that._current.node[name] = v;
        }
      });
    }

    /**
     * Returns a factory for the given node name.
     *
     * @param name {String} the name of the node
     * @returns {Function} the factory
     * @private
     */

  }, {
    key: '_resolveFactory',
    value: function _resolveFactory(name) {
      return this._factories[name];
    }

    /**
     * Sets up a parent child relationship.
     *
     * @param parent {Object} the parent node
     * @param child {Object} the child node
     * @private
     */

  }, {
    key: '_setParent',
    value: function _setParent(parent, child) {
      this._current.factory.setParent(this._child.builder, parent, child);
      this._emit('setParent', this._child.builder, parent, child);

      var parentFactory = this._parent.factory;
      if (parentFactory) {
        parentFactory.setChild(this._current.builder, parent, child);
        this._emit('setChild', this._child.builder, parent, child);
      }
    }

    /**
     * Unregisters global definitions
     *
     * @private
     */

  }, {
    key: '_unregisterGlobals',
    value: function _unregisterGlobals() {
      var _this2 = this;

      if (!this._globalsRegistered) {
        return;
      }
      _.forOwn(this._factories, function (f, n) {
        if (_this2._globalsStack[n] && _this2._globalsStack[n].length) {
          _this2._rootObj[n] = _this2._globalsStack[n].pop();
        } else {
          delete _this2._rootObj[n];
        }
      });
      this._propertyNames.forEach(function (name) {
        delete _this2._rootObj[name];
      });
      this._globalsRegistered = false;
    }

    /**
     *  Execute given closure to build nodes with this builder.
     *
     *  @param {Function} closure to execute
     *  @returns {object} the top level node built by the builder.
     */

  }, {
    key: 'build',
    value: function build(closure) {
      try {
        this._registerGlobals();
        return closure.call(this);
      } finally {
        this._unregisterGlobals();
      }
    }

    // noinspection JSUnusedGlobalSymbols
    /**
     *  `require` given file to build nodes with this builder.
     *
     *  @param file {String} file to load
     *  @param args {*[]} builder arguments
     *  @returns {object} the top level node built by the builder.
     */

  }, {
    key: 'buildFile',
    value: function buildFile(file) {
      try {
        this._registerGlobals();
        var res = module.require(file);
        if (typeof res === 'function') {
          var _res;

          for (var _len6 = arguments.length, args = Array(_len6 > 1 ? _len6 - 1 : 0), _key6 = 1; _key6 < _len6; _key6++) {
            args[_key6 - 1] = arguments[_key6];
          }

          res = (_res = res).call.apply(_res, [this].concat(args));
        }
        return res;
      } finally {
        this._unregisterGlobals();
      }
    }

    /**
     * Override to perform custom registration
     */

  }, {
    key: 'register',
    value: function register() {}

    /**
     *  Register a factory for a node name
     *
     * @param name {String} of the factory
     * @param factory
     */

  }, {
    key: 'registerFactory',
    value: function registerFactory(name, factory) {
      this._factories[name] = factory;
      this.emit('registerFactory', this, name, factory);
      if (this._globalsRegistered) {
        this._registerFactory(name);
      }
    }

    /**
     * Registers the given method names
     *
     * @param names {[String]} the method names
     */

  }, {
    key: 'registerMethodNames',
    value: function registerMethodNames() {
      var names = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

      this._methodNames = this._methodNames.concat(names);
      if (this._globalsRegistered) {
        names.forEach(this._registerMethod.bind(this));
      }
    }

    /**
     * Registers the given property names
     *
     * @param names {[String]} the property names
     */

  }, {
    key: 'registerPropertyNames',
    value: function registerPropertyNames() {
      var names = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

      this._propertyNames = this._propertyNames.concat(names);
      if (this._globalsRegistered) {
        names.forEach(this._registerProperty.bind(this));
      }
    }
  }, {
    key: '_child',
    get: function get() {
      return this._context._child;
    }
  }, {
    key: '_context',
    get: function get() {
      var len = this._contextStack.length;
      return len > 0 ? this._contextStack[len - 1] : null;
    }
  }, {
    key: '_contextStack',
    get: function get() {
      return this._parentBuilder ? this._parentBuilder._contextStack : this.__contextStack;
    }
  }, {
    key: '_rootObj',
    get: function get() {
      return this._parentBuilder ? this._parentBuilder._rootObj : this.__rootObj;
    }
  }, {
    key: '_current',
    get: function get() {
      return this._context._current;
    }
  }, {
    key: '_parent',
    get: function get() {
      return this._context._parent;
    }

    /**
     * Returns the builder's name
     *
     * @returns {String}
     */

  }, {
    key: 'name',
    get: function get() {
      return this._name;
    }

    // noinspection JSUnusedGlobalSymbols
    /**
     * Returns the builder's property names
     *
     * @returns {Array}
     */

  }, {
    key: 'propertyNames',
    get: function get() {
      return this._propertyNames;
    }
  }]);

  return JsDsl;
}(EventEmitter);

module.exports = JsDsl;